package academy.kovalevskyi.codingbootcamp.week2.day3.programmLogics;

public class Counter {
    /*Ссылку на класс Result мы будем получать из класса Logica*/
    public Result result;
    public int index;

    public Counter(Result result) {
        this.result = result;
    }

    /*Этот метод принимает массив, тот самый, который является игровым полем. В этом методе анализируется текущая
     * позиция в этом массиве, переопределяется индекс, возвращаются значения индекса (индекс - это ход, который должен
     * сделать компьютер*/
    public int process(String[] array) {
        recursion("0", array, -1);
        return index;
    }

    /*Метод recursion() вызывает сам себя. Позиция должна порождать ещё несколько позиций, чтобы перебрать все возможные
     * варианты. Когда мы вызываем метод recursion(), возникает новая позиция из предыдущей. В данном случае предыдущая
     * позиция - это массив arrayOut. Новая позиция это массив, являющийся копией массива arrayOut, в котором мы должны
     * походить Х или 0 (в зависимости от symbol), на соответствующую координату. После чего наш массив станет новой
     * позицией*/
    public int recursion(String symbol, String[] arrayOut, int coordinate) {
        /*Когда вызывается метод recursion(), нам приходит символ(к примеру Х). В нашей новой позиции мы походили
         * крестиком*/
        String[] array = arrayOut.clone();
        if (coordinate >= 0) {
            array[coordinate] = symbol;
        }
        /*Если крестик или нолик досрочно победил, ты метод заканчивает работу (мы вылетаем отсюда). 2 очка -
         * это победа, 1 очко - это ничья, 0 очков - это поражение.
         * Метод recursion() вернёт двойку, когда побеждают те, кто ходит в данную позицию. Допустим пришёл крестик,
         * появилась новая позиция array, эту позицию мы посылаем в result.process(), соответственно result.process()
         * сообщает нам, что победили крестики, т.е. оно возвращает нам строку с символом крестика. Сравниваем крестик
         * равен крестику(result.process(array) == symbol) - да, тогда возвращаем 2 - победа*/
        if (result.process(array) == symbol) {
            return 2;
        }
        /*После того, как в методе recursion() образовалась новая позиция, он вызывает сам себя несколько раз, тем самым
         * наша новая позиция array, становится родителем для новых позиций.
         * score - это результат противника. Противник определяется для текущей позиции, если в текущей позиции мы ходим
         * крестиками, противником для нас является нолик. maxScore - это самый лучший результат противника*/
        int score = 0, maxScore = -1, index = 0;
        /*Индексом i мы пробегаемся по всем точкам(ячейкам) игрового поля*/
        for (int i = 0; i < array.length; i++) {
            /*При прохождении по полю, проверяем что ячейка не имеет ни одного символа. Это условие одновременно является
             * условием выхода из рекурсии. В конце концов массив array рано или поздно окажется полностью заполненным
             * крестиками и ноликами*/
            if (array[i] == null) {
                if (symbol == "0") {
                    score = recursion("X", array, i);
                }
                /*Если мы походили крестиком, опять вызываем метод recursion(), в который приходит нолик, ведь следующий
                 * ход за ноликами, а также массив array (это наша позиция, с которой снимается копия и третий входящий
                 * параметр индекс i - это куда надо походить ноликом) в следующую позицию*/
                if (symbol == "X") {
                    score = recursion("0", array, i);
                }
                /*В эту строчку кода мы попадаем после того, как мы рассмотрели ход за крестик, который оказался сильнее
                * всех предыдущих ходов*/
                if (score > maxScore) {
                    maxScore = score;
                    index = i;
                }
            }
            this.index = index;
            if (maxScore == -1) {
                return 1;
            } else {
                return 2 - maxScore;
            }
        }
        return 0;
    }
}
