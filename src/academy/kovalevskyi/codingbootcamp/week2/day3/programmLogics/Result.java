package academy.kovalevskyi.codingbootcamp.week2.day3.programmLogics;

public class Result {
    private int width, height, distance;
    /*Создаём массив, так как process будет вызывать и другие методы, чтобы не писать лишние строки кода, создаём
     * общедоступный массив*/
    private String[] array;

    public Result(int width, int height, int distance) {
        this.width = width;
        this.height = height;
        this.distance = distance;
    }

    /*Этот метод сообщает есть ли три символа (Х или 0) в один ряд. Метод смотрит на свой одномерный массив, как на
    двумерный, ориентируясь по параметрам width, hieght*/
    public String process(String[] array) {
        this.array = array;

        /*Введём переменную i, которую будем увеличивать на один в цикле. Это будет счётчик заполненных полей*/
        int i = 0;
        /*Представим, что наш массив не одномерный, а двумерный. Создаём вложенные циклы for, в этих циклах мы
         * пробегаемся по всем точкам массива*/
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < height; x++) {
                /*Когда мы выводим какую-то точку, смотрим что у нас записано в массиве array. Если массив не равен null
                (то есть поле заполнено Х или 0), мы переменную i увеличиваем на единицу*/
                if (array[border(x, y)] != null) {
                    i++;
                }
                /*Из всех точек мы должны определить направления (8 направлений) есть ли в каком-то из направлений все
                 * крестики или нолики. Поэтому мы пишем ещё два цикла for, где мы и определим 8 векторов направления.*/
                for (int b = -1; b <= +1; b++) {
                    for (int a = -1; a <= +1; a++) {
                        /* Здесь мы исключаем вариант, когда a = 0 и b = 0. Ставим отрицание, чтобы не попасть в этот if*/
                        if (!(a == 0 && b == 0)) {
                            /*Вызываем метод check() внутри цикла, туда отправляем наши координаты (x, y), направление
                             * (a, b), которое надо проверить и символ("X"), который должен встречаться на этом направлении.
                             * Если на всём протяжении distance() будет встречаться только этот символ, то check() вернёт
                             * true*/
                            if (check(x, y, a, b, "X")) {
                                /*Если check() вернёт true, то возвращаем символ, который победил*/
                                return "X";
                            }
                            if (check(x, y, a, b, "0")) {
                                return "0";
                            }
                            /*Если все поля заполнены, но ни крестики ни нолики не победили(не выстроился ряд из трёх
                             * символов, то это будет тупик или ничья*/
                            if (i == array.length) {
                                return "deadlock";
                            }
                        }
                    }
                }
            }
        }
        /*Метод возвращает ничью, в случае когда на данный момент пока никто не выиграл*/
        return "draw";
    }

    /*Метод check() будет проверять три крестика или три нолика выстроенных в ряд в каком-либо направлении*/
    public boolean check(int x, int y, int a, int b, String symbol) {
        /*Проверяем направление от 0 до distance и на всём направлении должны быть только крестики или только нолики*/
        for (int i = 0; i < distance; i++) {
            /*Мы находимся в точке с координатами X, Y. Но массив одномерный и мы не знаем в какую точку одномерного
             * массива нам попасть, поэтому мы и вызываем метод border(), чтобы он перевёл эти координаты в одномерную
             * величину. Кроме того, когда мы, находясь в какой-то точке идём по вектору, мы можем упереться в тупик или
             * выйти за пределы поля, а метод border() сообщит нам об этом*/
            int index = border(x + a * i, y + b * i);
            /*Если по нашему направлению нам встретиться не наш символ, тогда возвращаем false*/
            if (index == -1) {
                return false;
            } else if (array[index] != symbol) {

            }
        }
        return true;
    }

    /* Метод border() (ограничитель) переводит двумерные координаты в одномерные. Если мы вышли за пределы матрицы, когда
     * координаты Х или Y, превышают значения ширины, высоты или являются отрицательными, то этот метод возвращает -1*/
    public int border(int x, int y) {
        if (x >= 0 && x < width && y > 0 && y < height) {
            //в этой строчке происходит перевод координат x, y в одномерную величину
            return y * width + x;
        }
        return -1;
    }
}
